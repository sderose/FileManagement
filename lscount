#!/usr/bin/perl -w
#
# lscount: Just say how many files.
#
# 2008-02-11: Convert from Bash, by Steven J. DeRose.
#     Better default-arg behavior. Mention hidden files.
# 2008-05-09 sjd: Account for . and .. as hidden files...
# 2010-09-12 sjd: Cleanup.
# 2010-09-29 sjd: Add -recursive, -all.
# 2011-08-01 sjd: Append /* for directories. Clean up.
# 2013-12-16: Clean up arg and glob handling and reporting.
# 2014-10-13: Fix case of no args at all.
#
# To do:
#
use strict;
use Getopt::Long;

our $VERSION_DATE = "2015-09-09";

my $all       = 0;
my $quiet     = 0;
my $recursive = 0;
my $verbose   = 0;


###############################################################################
# Process options
#
Getopt::Long::Configure ("ignore_case");
my $result = GetOptions(
    "all!"              => \$all,
    "h|help|?"          => sub { system "perldoc $0"; exit; },
    "q|quiet!"          => \$quiet,
    "recursive!"        => \$recursive,
    "v|verbose+"        => \$verbose,
    "version"           => sub {
       die "Version of $VERSION_DATE, by Steven J. DeRose.\n";
	}
	);
($result) || die "Bad options.\n";

($verbose) && warn "Args: '" . join(" ",@ARGV) . "'\n";


###############################################################################
###############################################################################
# Main
#
my $tot      = 0;
my $cmd      = "";
my $dirCount = 0;
my $hidCount = 0;
my $fmt      = "%-40s %6d\n";

my $a = ($all) ? "-a ":"";
if (scalar(@ARGV)<1) {
    @ARGV = `ls`;
}
for my $arg (@ARGV) {
    chomp $arg;
    if (!-d $arg) {
        $tot++;
        next;
    }
    if ($recursive) {
        $cmd = "ls -R $a $arg 2>/dev/null | wc -l";
    }
    else {
        $cmd = "ls $a $arg 2>/dev/null | wc -l";
    }
    $dirCount = `$cmd`;
    if ($verbose) { warn "Running: '$cmd'.\n"; }
    printf($fmt, $arg . (-d $arg ? '/':''), $dirCount);
    $tot += $dirCount;
    my $hidden = `ls -d $arg | wc -l`;
    $hidden -= 2; # Don't count . and ..
    if ($hidden>0) {
        print "    (also $hidden hidden files).\n";
        $hidCount += $hidden;
    }
}
printf($fmt, "* TOTAL *", $tot);
printf($fmt, "* Plus hidden *", $hidCount);

exit;



###############################################################################
###############################################################################
###############################################################################
#

=pod

=head1 Usage

lscount [options] [paths]

Say how many files there are in [paths], and in each directory listed in [paths].
Depends on the shell globbing the command line before we start, but handles any
directories listed if you specify I<-r>.


=head1 Options

=over

=item * B<-a>

Include hidden (.-initial) files.

=item * B<--quiet> OR B<-q>
Suppress most messages.

=item * B<-r>

Count files in entire subtree.

=item * B<--verbose> or B<-v>

Add more detailed messages.

=item * B<--version>

Display version info and exit.

=back


=head1 Known bugs and limitations

Depends on shell globbing (though not for I<-r>), so can't deal with very big
lists due to shell command-line length limits.


=head1 Ownership

This work by Steven J. DeRose is licensed under a Creative Commons
Attribution-Share Alike 3.0 Unported License. For further information on
this license, see L<http://creativecommons.org/licenses/by-sa/3.0/>.

For the most recent version, see L<http://www.derose.net/steve/utilities/>.

=cut
