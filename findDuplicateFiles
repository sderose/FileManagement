#!/usr/bin/env python
#
# findDuplicateFiles
#
# 2014-09-12: Written by Steven J. DeRose.
# 2019-10-29: Lint.
#
# To do:
#     Options to handle copy/backup, hidden, etc. --exclude/--include.
#
from __future__ import print_function
import sys
import os
import re
import argparse

#from sjdUtils import sjdUtils
from alogging import ALogger
lg = ALogger()

__version__ = "2019-10-29"


###############################################################################
# Process options
#
parser = argparse.ArgumentParser(
    description="""
=head1 Usage

findDuplicateFiles [options] [dirs]

Search all of the directories lists (recursively), for any filenames that
occur more than once. The filenames can be matched exactly, or in various
"fuzzy"/loose ways. Whitespace in names is always normalized and stripped.
However, files that may be the same but have entirely different names,
are not detected.


=head1 Related Commands

renameFiles, diffDirs, find.


=head1 Known bugs and limitations

No special Unicode normalizations except whitespace.


=head1 Ownership

This work by Steven J. DeRose is licensed under a Creative Commons
Attribution-Share Alike 3.0 Unported License. For further information on
this license, see L<http://creativecommons.org/licenses/by-sa/3.0/>.

For the most recent version, see L<http://www.derose.net/steve/utilities/>.

=cut

    """,
    epilog="(see also 'perldoc "+sys.argv[0]+"')"
)
parser.add_argument(
    "--color",            action='store_true',
    help='Colorize the output.')
parser.add_argument(
    "--nocolor",          action='store_false', dest="color",
    help='Turn off colorizing.')
parser.add_argument(
    "--hidden",           action='store_true',
    help='Include files/dirs whose names start with ".".')
parser.add_argument(
    "--iencoding",        type=str, metavar='E',
    help='Assume this character set for input files.')
parser.add_argument(
    "--ignoreCase", "-i", action='store_true',
    help='Disregard case distinctions.')
parser.add_argument(
    "--minDups",          type=int, default=2,
    help='Only report cases where there are more than this many duplicates.')
parser.add_argument(
    "--normalize",        action='store_true',
    help='Ignore modifiers like copy 4 of, Backup of backup of, ~, #, .bak....')
parser.add_argument(
    "--ndates",           action='store_true',
    help='Ignore date and time fields in names.')
parser.add_argument(
    "--nextensions",      action='store_true',
    help='Ignore differences such as .jpeg vs .jpg, .html vs .htm, etc.')
parser.add_argument(
    "--nserials",         action='store_true',
    help='Ignore trailing numbers before an extension (that is, \\s*\\d+).')
parser.add_argument(
    "--oencoding",        type=str, metavar='E',
    help='Assume this character set for output files.')
parser.add_argument(
    "--quiet", "-q",      action='store_true',
    help='Suppress most messages.')
parser.add_argument(
    "--unicode",          action='store_const',  dest='iencoding',
    const='utf8', help='Assume utf-8 for input files.')
parser.add_argument(
    "--verbose", "-v",    action='count',       default=0,
    help='Add more messages (repeatable).')
parser.add_argument(
    "--version",          action='version',     version='Version of '+__version__,
    help='Display version information, then exit.')

parser.add_argument(
    'files',             type=str,
    nargs=argparse.REMAINDER,
    help='Path(s) to input file(s)')

args = parser.parse_args()
if (args.color is None):
    args.color = ("USE_COLOR" in os.environ and sys.stderr.isatty())
lg.setColors(args.color)
lg.setVerbose(args.verbose)


###############################################################################
###############################################################################
#
extensionMap = {
    r'html': 'htm',
    r'jpeg': 'jpg',
    r'text': 'txt',
}

dateExpr = r'(\d\d\d\d[-.]\d\d[-.]\d\d|\d\d/\d\d/\d\d(\d\d)?)'
timeExpr = r'\d\d[-:]\d\d[-:]\d\d(\.\d+)(Z|[ESMP][SD]T]|GMT|[-+]\d+)?'
dateTimeExpr = dateExpr + r'[- T@:.]' + timeExpr
cdte = re.compile(dateTimeExpr)

def normalizeFilename(name,
    case       = True,
    space      = True,
    special    = True,
    dates      = True,
    serials    = True,
    extensions = True,
    ):
    "cf diffDirs.py"
    if (case):
        name = name.lower()
    if (space):
        name = re.sub(r'\s+', ' ', name, re.UNICODE).strip()
    if (special):
        name = re.sub(r'^((backup|copy|alias)( \d+)? of )+', '', name, re.I)
        name = re.sub(r' (backup|copy|alias)( \d+)?$', '', name, re.I)
        name = re.sub(r'.(bak|bck)$', '', name, re.I)
        name = name.strip('#~')
    if (dates):
        name = re.sub(cdte, '', name).strip()
    if (serials):
        name = re.sub(r'\s*\d+(\.\w+)$', r'\\1', name)
    if (extensions):
        for pair in extensionMap:
            if (name.endswith('.'+pair[0])):
                oldLen = len(pair[0])
                name = name[0:-oldLen] + pair[1]
                break

    return(name)


def loadDirList(dirName, fileDict=None, recursive=True):
    if (fileDict is None): fileDict = {}
    if (not os.path.isdir(dirName)):
        lg.error("Not a directory: %s." % (dirName))
        return(fileDict)

    for f in (os.listdir(dirName)):
        if (f[0]=='.' and not args.hidden): continue
        path = os.path.join(dirName,f)
        if (os.path.isdir(path)):
            if (recursive): loadDirList(path, fileDict)
        else:
            fileDict[path] = ( os.path.getmtime(path), os.path.getsize(path) )
    return(fileDict)



###############################################################################
###############################################################################
# Main
#
totalRecords = 0
totalFiles = 0

fileLists = []
fileCounts = []

for dnum in (range(0, len(args.files))):
    cur = {}
    cur = loadDirList(args.files[dnum], cur)
    fileLists.append(cur)
    fileCounts.append(len(cur))

lg.vMsg(0, "Done loading. File counts by directory tree:")
lg.MsgPush()
for dnum in (range(0, len(args.files))):
    lg.vMsg(0, "%8d %s" % (fileCounts[dnum], args.files[dnum]))
lg.MsgPop()


union = {}
ndups = 0
for dnum in (range(len(args.files))):
    for k, y in fileLists[dnum].items():
        base = os.path.basename(k)
        base = normalizeFilename(
            base,
            case       = args.args.ignoreCase,
            space      = True,
            special    = args.normalize,
            dates      = args.ndates,
            serials    = args.nserials,
            extensions = args.nextensions
        )

        if (base not in union):
            base[union] = [ y ]
        else:
            ndups += 1
            base[union].append(y)

lg.vMsg(0, "Done scanning. Total duplicates: %d." % (ndups))

for k, v in union:
    if (len(v) > args.minDups):
        print("%s\n    %s\n" % (k, "\n    ".join(v)))

if (not args.quiet):
    lg.vMsg(0,"Done.")

sys.exit(0)

